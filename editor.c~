#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <strings.h> // Pour strcasecmp
#include "editor.h"

// --- Fonctions basiques et Avancées (Gardées pour la complétude) ---

void load_file(TextFile *tf, const char *filename) {
    FILE *file = fopen(filename, "r");
    tf->line_count = 0;
    if (!file) {
        printf("Could not open file. Starting with empty file.\n");
        return;
    }
    char buffer[MAX_LINE_LENGTH];
    while (fgets(buffer, MAX_LINE_LENGTH, file) && tf->line_count < MAX_LINES) {
        tf->lines[tf->line_count] = strdup(buffer);
        tf->line_count++;
    }
    fclose(file);
}

void save_file(TextFile *tf, const char *filename) {
    FILE *file = fopen(filename, "w");
    if (!file) {
        printf("Error opening file for writing.\n");
        return;
    }
    for (int i = 0; i < tf->line_count; i++) {
        fputs(tf->lines[i], file);
    }
    fclose(file);
    printf("File saved successfully.\n");
}

void print_file(TextFile *tf) {
    for (int i = 0; i < tf->line_count; i++) {
        printf("%d: %s", i + 1, tf->lines[i]);
    }
}

void edit_line(TextFile *tf) {
    int line_number;
    printf("Enter line number to edit (1-%d): ", tf->line_count);
    if (scanf("%d", &line_number) != 1) {
        printf("Invalid input.\n");
        while(getchar() != '\n');
        return;
    }
    getchar(); 
    
    if (line_number < 1 || line_number > tf->line_count) {
        printf("Invalid line number.\n");
        return;
    }
    
    printf("Current line: %s", tf->lines[line_number - 1]);
    printf("Enter new content: ");
    char new_content[MAX_LINE_LENGTH];
    
    if (fgets(new_content, MAX_LINE_LENGTH, stdin) == NULL) {
        return;
    }
    
    free(tf->lines[line_number - 1]);
    tf->lines[line_number - 1] = strdup(new_content);
    printf("Line %d updated.\n", line_number);
}

void free_file(TextFile *tf) {
    for (int i = 0; i < tf->line_count; i++) {
        free(tf->lines[i]);
    }
}

void search_text(TextFile *tf, const char *word) {
    printf("Searching for '%s':\n", word);
    for (int i = 0; i < tf->line_count; i++) {
        if (strstr(tf->lines[i], word)) { 
            printf("%d: %s", i + 1, tf->lines[i]);
        }
    }
}

void spell_check(TextFile *tf, char **dictionary, int dict_size) {
    printf("Spell checking...\n");
    for (int i = 0; i < tf->line_count; i++) {
        char copy[MAX_LINE_LENGTH]; 
        strncpy(copy, tf->lines[i], MAX_LINE_LENGTH - 1);
        copy[MAX_LINE_LENGTH - 1] = '\0';
        
        char *token = strtok(copy, " \t\n,.!?:;\"()"); 
        while (token) {
            size_t len = strlen(token);
            while (len > 0 && ispunct((unsigned char)token[len - 1])) {
                token[--len] = '\0';
            }
            
            if (len == 0) {
                token = strtok(NULL, " \t\n,.!?:;\"()");
                continue;
            }
            
            int found = 0;
            for (int j = 0; j < dict_size; j++) {
                if (strcasecmp(token, dictionary[j]) == 0) {
                    found = 1;
                    break;
                }
            }
            if (!found) {
                printf("Line %d: Unknown word '%s'\n", i + 1, token);
            }
            token = strtok(NULL, " \t\n,.!?:;\"()");
        }
    }
}

void autocomplete(const char *prefix, char **dictionary, int dict_size) {
    printf("Autocomplete suggestions for '%s':\n", prefix);
    int count = 0;
    for (int i = 0; i < dict_size && count < MAX_SUGGESTIONS; i++) {
        if (strncasecmp(prefix, dictionary[i], strlen(prefix)) == 0) {
            printf("  %s\n", dictionary[i]);
            count++;
        }
    }
    if (count == 0) {
        printf("  No suggestions found.\n");
    }
}

int load_dictionary(const char *filename, char **dictionary, int max_words) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        printf("Cannot open dictionary file '%s'\n", filename);
        return 0;
    }
    int count = 0;
    char buffer[MAX_LINE_LENGTH];
    while (fgets(buffer, MAX_LINE_LENGTH, file) && count < max_words) {
        buffer[strcspn(buffer, "\n")] = 0; 
        dictionary[count] = strdup(buffer);
        count++;
    }
    fclose(file);
    printf("%d words loaded into dictionary.\n", count);
    return count;
}


// --- CRDT Simulation Implementation (Nouveau) ---

void apply_crdt_operation(TextFile *tf, CRDTC_Operation *op) {
    if (op->line_index < 0 || op->line_index >= tf->line_count) {
        printf("CRDT Error: Invalid line index.\n");
        return;
    }

    char *target_line = tf->lines[op->line_index];
    int current_len = strlen(target_line);

    if (op->char_index < 0 || op->char_index > current_len) {
        printf("CRDT Error: Invalid character index.\n");
        return;
    }

    if (op->type == INSERT) {
        char *insert_content = op->content;
        if (!insert_content) return;
        
        int insert_len = strlen(insert_content);
        // +1 pour \0
        int new_len = current_len + insert_len + 1; 

        char *new_line = (char *)malloc(new_len);
        if (new_line == NULL) {
            perror("Memory allocation failed for CRDT insert");
            return;
        }

        // 1. Copier la partie avant l'insertion
        strncpy(new_line, target_line, op->char_index);

        // 2. Copier le contenu à insérer
        memcpy(new_line + op->char_index, insert_content, insert_len);

        // 3. Copier le reste de l'ancienne ligne (y compris \0)
        memcpy(new_line + op->char_index + insert_len, target_line + op->char_index, current_len - op->char_index + 1);
        
        free(target_line); 
        tf->lines[op->line_index] = new_line;
        printf("CRDT Applied: INSERT '%s' by Site %d on Line %d.\n", insert_content, op->site_id, op->line_index + 1);
        
    } else if (op->type == DELETE) {
        if (current_len > 0) {
            // Déplacer les caractères après l'index de suppression vers la gauche
            // Note: memmove gère le chevauchement de mémoire, contrairement à memcpy
            memmove(target_line + op->char_index, target_line + op->char_index + 1, current_len - op->char_index);
            target_line[current_len - 1] = '\0';
            printf("CRDT Applied: DELETE by Site %d on Line %d.\n", op->site_id, op->line_index + 1);
        }
    }
}
